
% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass[10pt,a4paper]{article}
%\documentclass{llncs}
%
%\synctex=1

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%\usepackage[T1]{fontenc}
%\usepackage{lmodern}

\usepackage{graphicx}
\usepackage{epsfig}

\usepackage{array}
%\setlength{\extrarowheight}{0pt}


%\usepackage{bigstrut}
%    \setlength\bigstrutjot{3pt}


\usepackage{amssymb}
%\usepackage{MnSymbol}
\usepackage{bm}
\usepackage{amsmath}

\usepackage{bussproofs}
\usepackage[USenglish]{babel}

\usepackage{subfigure}

\usepackage{times}

\usepackage{booktabs}

\usepackage{float}

\usepackage{multirow}


\usepackage{todonotes}

%\usepackage[T1]{fontenc}
%\usepackage{cmbright}


% \fontencoding{T1}
%  \fontfamily{garamond}
%  \fontseries{m}
%  \fontshape{it}
%  \fontsize{12}{15}
%  \selectfont

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\code}[1]{{\fontfamily{cmtt}\small\selectfont#1}}
\newcommand{\codefs}[1]{{\fontfamily{cmtt}\scriptsize\selectfont#1}}


%\usepackage{fancyvrb}
%\DefineVerbatimEnvironment{codenv}{Verbatim}{fontfamily=ssf}
%cmss
%{\begin{Verbatim}[fontfamily=cmss]}% 
%{\end{Verbatim}}%

% multiline comments
\usepackage{verbatim} 

\usepackage{color}
\usepackage{listings}

%  basicstyle=\sffamily\small,


\lstdefinelanguage{Scala}{
	morekeywords={},
	morekeywords=[2]{
		public, private, protected,
		abstract,case,catch,class,def,
		do,else,extends,false,final,finally,
		for,if,implicit,import,match,mixin,
		new,null,object,override,package,
		private,protected,requires,return,sealed,
		super,this,throw,trait,true,try,
		type,val,var,while,with,yield,
		lazy,evt,observable,imperative,
                after,before},
	otherkeywords={=>,<-,<\%,<:,>:,\#,@},
	sensitive=true,
	morecomment=[l]{//},
	morecomment=[n]{/*}{*/},
	morestring=[b]",
	morestring=[b]',
	morestring=[b]"""
}
\lstloadlanguages{Scala}

\lstset{
  backgroundcolor=\color{white},%\fontfamily{cmtt}
  basicstyle=\fontfamily{cmtt}\scriptsize,
  basewidth=0.5em,
  showstringspaces=false,
  keywordstyle=\fontfamily{pcr}\color[rgb]{0,0,0}\bfseries,
  %commentstyle=\color[rgb]{0.133,0.545,0.133},
  %stringstyle=\color[rgb]{0.627,0.126,0.941},
  breaklines=false,
  frame=none
  breaklines=false,
  frame=none,
  numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,
  %frameround=fttt,
  %frame=single,
  escapeinside={(*@}{@*)},
  %columns=fullflexible
}


\lstnewenvironment{codenv}{\lstset{language=Scala}}{}
\lstnewenvironment{codenvOpt}[1]{\lstset{language=Scala,#1}}{}


\newenvironment{bluetext}{\color{blue}}{\ignorespacesafterend}
\newenvironment{redtext}{\color{red}}{\ignorespacesafterend}
\newcommand{\bygerold}[1]{ \begin{bluetext} #1 \end{bluetext}}
\newcommand{\commentbygerold}[1]{\\\begin{redtext} #1 \end{redtext}\\}

%\newenvironment{codenv}{\small \begin{itshape}}{ \end{itshape}}



%\renewcommand*{\bibfont}{\footnotesize}



% Avoid (not that) big pictures alone in a blank page
\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}

\usepackage{xspace}
\newcommand{\REScala}{{\small \sc{REScala}}\xspace}


\newcommand{\mm}[1]{\todo[color=green!40]{#1}}
\newcommand{\jd}[1]{\todo[color=blue!40]{#1}}
\newcommand{\gs}[1]{\todo[color=red!40]{#1}}

\usepackage{color}


\hyphenation{Res-ca-la}


\newcommand{\str}[1]{{\sf\selectfont @#1@}\newline}





\title{REScala Reference Manual}

\date{November 2013}

\author{Guido Salvaneschi\\ Technical University of Darmstadt\\
\code{salvaneschi@informatik.tu-darmstadt.de}\\}


\begin{document}

\maketitle
\newpage
\pagenumbering{Roman}
\tableofcontents
%\newpage
%\listoffigures
%\newpage
%\listoftables
\newpage
\pagenumbering{arabic}







\section{Signals and Vars}

A signal is language concept for expressing functional dependencies
among values in a declarative way. Intuitively, a reactive value can
depend on variables -- sources of change without further dependencies
-- or on other reactive values.  When any of the dependency sources
changes, the expression defining the reactive value is automatically
recomputed by the language runtime to keep the reactive value
up-to-date.

Consider the following example:

\begin{codenv}
var a = 2
var b = 3
var c = a + b   (*@\label{sum}@*)
println(a,b,c) // -> (2,3,5)
a = 4
println(a,b,c) // -> (2,4,5) (*@\label{nomore}@*)
c = a + b (*@\label{update}@*)
println(a,b,c) // -> (4,3,7)
\end{codenv}

Line~\ref{sum} specifies the value of \code{c} as a function of
\code{a} and \code{b}. Since Line~\ref{sum} defines a statement, the
relation $c = a + b$ is valid after the execution of
Line~\ref{sum}. Clearly, when the value of \code{a} is updated, the
relation $c = a + b$ is not valid anymore (Line~\ref{nomore}). To make
sure that the relation still holds, the programmer needs to recompute
the expression and reassign \code{c}, like in line \ref{update}.
\\

Reactive programming and REScala provide abstraction to express {\em
  constraints} in addition to statements. In REScala the programmer
can specify that the constraint $c := a + b$ {\em always} holds during
the execution of a program, and every time \code{a} o \code{b} change,
the value of \code{c} is automatically recomputed.

For example:
\begin{codenv}
val a = Var(2)
val b = Var(3)
val c = Signal{ a() + b() }   (*@\label{sumS}@*)
println(a.getVal,b.getVal,c.getVal) // -> (2,3,5)
a()= 4
println(a,b,c) // -> (2,4,5) (*@\label{updated}@*)
println(a.getVal,b.getVal,c.getVal) // -> (4,3,7)
\end{codenv}

In the code above, the \code{Signal} in Line~\ref{sumS} defines the
constraint $c := a + b$. When one of the variables involved in the
constraint is updated (Line~\ref{updated}), the expression in the
constraint is recomputed behind the scenes, and the value of \code{a}
is automatically updated.

As the reader may have noticed, expressing constraints in REScala
requires to conform some syntactic conventions. 


\paragraph{Defining Vars} Programmers express reactive computations
starting from vars. Vars wrap normal Scala values. For example
\code{Var(2)} create a var with an \code[Int] value and initializes it
to the value 2. Vars are parametric types. A var that carries integers
has the type \code{Var[Int]}. The following are all valid vars
declarations.

\begin{codenv}
val a = Var(0) 
val b = Var("Hello World")  
val c = Var(false)  
val d: Var[Int] = Var(30) 
val e: Var[String] = Var("REScala")  
val f: Var[Boolean] = Var(false)  
\end{codenv}


\paragraph{Assigning Vars} Vars can be directly modified with the
\code{()=} operator. For example \code{v()=3} replaces the current
value of the \code{v} var with \code{3}. 

\paragraph{Defining Signals} Signals are defined by the syntax
\code{Signal\{}{\it sigexpr}\code{\}}, where {\it sigexpr} is a side
effect-free expression. Signals are parametric types. A signal that
carries integers has the type \code{Signal[Int]}.

\paragraph{Signal expressions} When, inside a signal expression
defining a signal \code{s}, a var or a signal is called with the
\code{()} operator, the var of the signal are added to the values
\code{s} depends on. In that case \code{s} {\it is a dependency} of
the vars and the signals in the signal expression. All the following
code snippets define valid signal declarations.


\begin{codenv}
val a = Var(0) 
val s: Signal[Int] = Signal{ a() + 1 }
\end{codenv}

\begin{codenv}
val a = Var(0) 
val b = Var(0) 
val s = Signal{ a() + b() } // Multiple vars is a signal expression
\end{codenv}

\begin{codenv}
val a = Var(0) 
val b = Var(0)
val c = Var(0)
val s = Signal{ a() + b() }
val t = Signal{ s() * c() + 10 } // Mix signals and vars in signal expressions
\end{codenv}

\begin{codenv}
val a = Var(0) 
val b = Var(0)
val c = Var(0)
val s = Signal{ a() + b() }
val t = Signal{ s() * c() + 10 }
val u = Signal{ s() * t() } // A signal that depends on other signals
\end{codenv}


\begin{codenv}
val a = Var(0) 
val b = Var(2)
val c = Var(true)
val s = Signal{ if (c()) a() else b() }
\end{codenv}

\begin{codenv}
def factorial(n: Int) = ...
val a = Var(0) 
val s: Signal[Int] = Signal{ // A signal expression can be any code block
  val tmp = a() * 2
  val k = factorial(tmp)
  k + 2  // Returns an Int
}
\end{codenv}




\paragraph{Reading reactive values} The current value of a signal or a
var can be accessed using the \code{getVal} method. For example:

\begin{codenv}
val a = Var(0) 
val b = Var(2)
val c = Var(true)
val s: Signal[Int] = Signal{ a() + b() }
val t: Signal[Boolean] = Signal{ !c() }

val x: Int = a.getVal 
val y: Int = s.getVal 
val x: Boolean = t.getVal 
\end{codenv}



\subsubsection{Example: speed}
The following example computes the displacement \code{space} of a
particle that is moving at constant speed \code{SPEED}. The
application prints all the values of the displacement.

\begin{codenv}
val SPEED = 10
val time = Var(0)  
val space = Signal{ SPEED * time() } (*@\label{sigexpr}@*)
  
space.changed += ((x: Int) => println(x)) (*@\label{conversion}@*)
  
while (true) {
  Thread sleep 20
  time() = time.getVal + 1  (*@\label{increasetime}@*)
}

-- output --
10
20
30
40
 ...
\end{codenv}


The application behaves as follows. Every 20 milliseconds, the value
of the \code{time} var is increased by 1 (Line~\ref{increasetime}).
When the value of the \code{time} var changes, the signal expression
at Line~\ref{sigexpr} is executed and the value of \code{space} is
updated. Finally, the current value of the \code{space} signal every
time the value of the signal changes. Technically, this is achieved by
converting the \code{space} signal to an event that is fired every
time the signal changes its value (Line~\ref{conversion}). The
conversion is performed by the \code{changed} operator. The \code{+=}
operator attaches an handler to the event returned by the
\code{changed} operator. When the event fires, the handler is
executed.

Line~\ref{conversion} is equivalent to the following code:

\begin{codenv}
val e: Event[Int] = space.changed
val handler:  (Int => Unit) =  ((x: Int) => println(x))
e += handler
\end{codenv}


\section{Events}


\subsection{Imperative events}

\subsubsection{Defining  Events}

REScala supports imperative events. Imperative events are defined by
the \code{ImperativeEvent[T]} type. The value of the parameter
\code{T} defines the value that is attached to an event.

Fir example the following code snippet defines and imperative events
whose attached value is an integer:
\begin{codenv}
val e = new ImperativeEvent[Int]()
\end{codenv}

\subsubsection{Registering Handlers}

Handlers can be defined attaching a code block to the event. The
\code{+=} operator attaches the handler to the event.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }
\end{codenv}

- Other ways to register a handler ? Alternative syntax for handlers


When a handler is registered to an event, the handler is executed
every time the event is fired. If multiple handlers are registered,
all of them are executed when the event is fired. Applications should
not rely on any specific execution order for handler execution.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }
\end{codenv}


The signature of the event handlers must conform the signature of the
events.





\subsubsection{Firing Events}


Events can be fired with the same syntax of a method call. For example
the event \code{e} in the following example is fired by the
\code{e(10)} call.

\begin{codenv}
val e = new ImperativeEvent[Int]()
e(10)
\end{codenv}



\subsubsection{Registering Handlers}

Handlers can be unregistered from events by the \code{-=} operator.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }


e += { println() }
\end{codenv}




\subsection{Declarative Events}


REScala supports declarative events, which are defined as a
combination of other events. For this purpose it offers operators like
$e_1||e_2$ (occurrence of one among $e_1$ or $e_2$), $e_1\&\&p$ ($e_1$
occurs and the predicate $p$ is satisfied), $e_1.map(f)$ (the event
obtained by applying $f$ to $e_1$).  Event composition allows to
express the application logic in a clear and declarative way. Also,
the update logic is better localized because a single expression
models all the sources and the transformations that define an event
occurrence.











\section{Conversion Functions}

\REScala provides functions that interface signals and events. Some of
those functions can be called on a signal passing an event as the
first parameter or can be called on an event passing a signal as the
first parameter. While the behavior is the same, the signature of the
function is obviously different. For simplicity, in those cases, here
we only document the signature of the function called on the signal.


\subsubsection*{fold}

Creates a signal by folding events with a given function.\\
\code{fold[T,A](e: Event[T], init: A)(f :(A,T)=>A): Signal[A]}

\begin{codenv}
val e = new ImperativeEvent[Int]()
val f = (x:Int,y:Int)=>(x+y)
val s: Signal[Int] = e.fold(10)(f)
e(1)
e(2)
assert(s.getValue == 13)
\end{codenv}


\subsubsection*{iterate}
Returns a value computed by \code{f} on the occurrence of an event.\\
\code{iterate[A](e: Event[\_], init: A)(f: A=>A) :Signal[A]}



\subsubsection*{hold}
Returns a signal holding the latest value of the event \code{e}.\\
\code{hold[T](e: Event[T], init: T): Signal[T]}\\

\noindent
Holds the latest value of an event as \code{Some(val)} or \code{None}.\\
\code{holdOption[T](e: Event[T]): Signal[Option[T]]}

\subsubsection*{last}
Returns a signal which holds the last \code{n} events.\\
\code{last[T](e: Event[T], n: Int): Signal[List[T]]}

\subsubsection*{list}
Collects the event values in a reactive list.\\
\code{list[T](e: Event[T]): Signal[List[T]]}

\subsubsection*{reset}
On the event, sets the signal to one generated by the factory.\\
\code{reset[T,A](e: Event[T], init: T)(f: (T)=>Signal[A]): Signal[A]}

\subsubsection*{switch}
Switches the value of the signal on the occurrence of \code{e}.\\
\code{switchTo[U](e :Event[U])(f: U=>T): Signal[T]}\\
\code{switchTo(e: Event[T]): Signal[T]}\\

\noindent
Switches to a new signal once, on the occurrence of \code{e}.\\
\code{switchOnce(e: Event[\_])(op: =>T): Signal[T]}\\
\code{switchOnce(e: Event[\_], newSignal: Signal[T]): Signal[T]}\\

\noindent
Switches between signals on the event \code{e}.\\
\code{toggle(e: =>Event[\_])(op: =>T): Signal[T]}\\
\code{toggle(e: =>Event[\_], other: Signal[T]): Signal[T]}

\subsubsection*{snapshot}
Returns a signal updated only when \code{e} fires.\\
\code{snapshot(e: Event[\_]): Signal[T]}






\section{Technicalities}~\label{sec:technicalities}

To work with REScala you need to properly import the reactive
abstractions offered by the language. The following imports are
normally sufficient for all REScala functionalities:

\begin{codenv}
import react._
import react.events._
import macro.SignalMacro.{SignalM => Signal}
\end{codenv}

Note that signal expressions are currently implemented as macros,
i.e. the body of a signal expression is macroexpanded. To use macros
for signal expressions, the macro \code{SignalM} is imported and
renamed to \code{Signal} (Line 3).




\section{Common Pitfalls}~\label{sec:pitfalls} In this section we
collect some mistakes that are common to users that are new to
reactive programming and REScala. 


\subsection{Accessing values in signal expressions} The \code{()}
operator used on a signal or a var, inside a signal expression,
returns the signal/var value {\it and} creates a dependency. The
\code{getVal} operator returns the current value but does {\it not}
create a dependency. For example the following signal declaration
creates a dependency between \code{a} and \code{s}, and a dependency
between \code{b} and \code{s}.
\begin{codenv}
val s = Signal{ a() + b() }
\end{codenv}
The following code instead establishes only a dependency between
\code{b} and \code{s}.
\begin{codenv}
val s = Signal{ a.getVal + b() }
\end{codenv}
In other words, if \code{a} is updated, \code{s} is not automatically
updated. With the exception of rare cases in which this behavior is
desirable, this is almost certainly a mistake. As a rule of dumb,
signals and vars appear in signal expressions with the \code{()}
operator.


\subsection{Attempting to assign a signal} Signals are not
assignable. Signal depends on other signals and vars, the dependency
is expressed by the signal expression. The value of the signal is
automatically updated when one of the values it depends on
changes. Any attempt to set the value of a signal manually is a
mistake.


\subsection{Side effects in signal expressions} Signal expressions
should be pure. i.e. they should not modify external variables. For
example the following code is conceptually wrong because the variable
\code{c} is imperatively assigned form inside the signal expression
(Line~\ref{assign}).
\begin{codenv}
var c = 0                 /* WRONG - DON'T DO IT */
val s = Signal{ 
  val sum = a() + b(); 
  c = sum * 2  (*@\label{assign}@*)
}
 ...
foo(c)
\end{codenv}

A possible solution is to refactor the code above to a more functional
style. For example by removing the variable \code{c} and replacing it
directly with the signal.
\begin{codenv}
val c = Signal{ 
  val sum = a() + b(); 
  sum * 2  
}
 ...
foo(c.getVal)
\end{codenv}



\subsection{Cyclic dependencies} When a signal \code{s} is defined, a
dependency is establishes with each of the signals or vars that appear
in the signal expression of \code{s}. Cyclic dependencies produce a
runtime error and must be avoided. For example the following code:

\begin{codenv}
val a = Var(0)             /* WRONG - DON'T DO IT */
val s = Signal{ a() + t() }
val t = Signal{ a() + s() + 1 }
\end{codenv}

creates a mutual dependencies between \code{s} and \code{t}. Similarly
indirect cyclic dependencies must be avoided.



\subsection{Objects and mutability} Vars and signals may behave
unexpectedly with mutable objects. Consider the following example.

\begin{codenv}
class Foo(init: Int){            /* WRONG - DON'T DO IT */
  var x = init
}
val foo = new Foo(1)

val varFoo = Var(foo)           
val s = Signal{ varFoo().x + 10 }
// s.getVal == 11
foo.x = 2 (*@\label{same}@*)
// s.getVal == 11 
\end{codenv}

One may expect that after increasing the value of \code{foo.x} in
Line~\ref{same}, the signal expression is evaluated again and updated
to 12. The reason why the application behaves differently is that
signals and vars hold {\it references} to objects, not the objects
themselves. When the statement in line Line~\ref{same} is executed,
the value of the \code{x} field changes, but the reference hold by the
\code{varFoo} var is the same. For this reason, no change is detected
by the var, the var does not propagate the change to the signal and
the signal is not reevaluated.

A solution to this problem is to use immutable objects. Since the
objects cannot be modified, the only way to change a filed is to
create an entirely new object and assign it to the var. As a result
the var is reevaluated.

\begin{codenv}
class Foo(x: Int){}
val foo = new Foo(1)

val varFoo = Var(foo)           
val s = Signal{ varFoo().x + 10 }
// s.getVal == 11
varFoo()= newFoo(2)
// s.getVal == 12 
\end{codenv}

Alternatively one can still use mutable objects but assign again the
var to force the reevaluation. However this style of programming is
confusing for the reader and should be avoided when possible.

\begin{codenv}
class Foo(init: Int){
  var x = init
}
val foo = new Foo(1)

val varFoo = Var(foo)           
val s = Signal{ varFoo().x + 10 }
// s.getVal == 11
foo.x = 2 (*@\label{same}@*)
varFoo()=foo
// s.getVal == 11 
\end{codenv}


\subsection{Functions of reactive values} Functions that operate on
traditional values are not automatically transformed to operate on
signals. For example consider the following functions:

\begin{codenv}
def increment(x: Int): (Int=>Int) = x + 1
\end{codenv}

The following code does not compile because the compiler expects an
integer, not a var as a parameter of the \code{increment} function. In
addition, since the \code{increment} function returns an integer,
\code{b} has type \code{Int}, and the call \code{b()} in the signal
expression is also rejected by the compiler.

\begin{codenv}
val a = Var(1)           /* WRONG - DON'T DO IT */
val b = increment(a)
val s = Signal{ b() + 1 }
\end{codenv}

The following code snippet is syntactically correct, but the signal
has a constant value 2 and is not updated when the var changes.

\begin{codenv}
val a = Var(1) 
val b = increment(a.getVal)
val s = Signal{ b + 1 }
\end{codenv}

The following solution is syntactically correct and the signal
\code{s} is updated every time the var \code{a} is updated.

\begin{codenv}
val a = Var(1) 
val s = Signal{ increment(a()) + 1 }
\end{codenv}






\section{Related Work}~\label{sec:related}

A complete bibliography on reactive programming is beyond the scope of
this work. The interested reader can refer
to~\cite{rective-progr-survey} for an overview of reactive programming
and to~\cite{Salvaneschi:2013:RBO:2451436.2451442} for the issues
concerning the integration of RP with object-oriented programming.


REScala builds on ideas originally developed in
EScala~\cite{Gasiunas:2011:EME:1960275.1960303} -- which supports
event combination and implicit events. Other reactive languages
directly represent time-changing values and remove inversion of
control. Among the others, we mention
FrTime~\cite{DBLP:conf/esop/CooperK06} (Scheme),
FlapJax~\cite{Meyerovich:2009:FPL:1640089.1640091} (Javascript),
AmbientTalk/R~\cite{ambienttalkR} and
Scala.React~\cite{EPFL-REPORT-148043} (Scala).


\section{Acknowledgments}

Several people contributed to this manual with their comments. Among
the others Gerold Hintz and Pascal Weisenburger.


\bibliographystyle{abbrv}
\bibliography{manual}




\end{document}














