
% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass[10pt,a4paper]{article}
%\documentclass{llncs}
%
%\synctex=1

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%\usepackage[T1]{fontenc}
%\usepackage{lmodern}

\usepackage{graphicx}
\usepackage{epsfig}

\usepackage{array}
%\setlength{\extrarowheight}{0pt}


%\usepackage{bigstrut}
%    \setlength\bigstrutjot{3pt}


\usepackage{amssymb}
%\usepackage{MnSymbol}
\usepackage{bm}
\usepackage{amsmath}

\usepackage{bussproofs}
\usepackage[USenglish]{babel}

\usepackage{subfigure}

\usepackage{times}

\usepackage{booktabs}

\usepackage{float}

\usepackage{multirow}


\usepackage{todonotes}

%\usepackage[T1]{fontenc}
%\usepackage{cmbright}


% \fontencoding{T1}
%  \fontfamily{garamond}
%  \fontseries{m}
%  \fontshape{it}
%  \fontsize{12}{15}
%  \selectfont

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\code}[1]{{\fontfamily{cmtt}\small\selectfont#1}}
\newcommand{\codefs}[1]{{\fontfamily{cmtt}\scriptsize\selectfont#1}}


%\usepackage{fancyvrb}
%\DefineVerbatimEnvironment{codenv}{Verbatim}{fontfamily=ssf}
%cmss
%{\begin{Verbatim}[fontfamily=cmss]}% 
%{\end{Verbatim}}%

% multiline comments
\usepackage{verbatim} 

\usepackage{color}
\usepackage{listings}

%  basicstyle=\sffamily\small,


\lstdefinelanguage{Scala}{
	morekeywords={},
	morekeywords=[2]{
		public, private, protected,
		abstract,case,catch,class,def,
		do,else,extends,false,final,finally,
		for,if,implicit,import,match,mixin,
		new,null,object,override,package,
		private,protected,requires,return,sealed,
		super,this,throw,trait,true,try,
		type,val,var,while,with,yield,
		lazy,evt,observable,imperative,
                after,before},
	otherkeywords={=>,<-,<\%,<:,>:,\#,@},
	sensitive=true,
	morecomment=[l]{//},
	morecomment=[n]{/*}{*/},
	morestring=[b]",
	morestring=[b]',
	morestring=[b]"""
}
\lstloadlanguages{Scala}

\lstset{
  backgroundcolor=\color{white},%\fontfamily{cmtt}
  basicstyle=\fontfamily{cmtt}\scriptsize,
  basewidth=0.5em,
  showstringspaces=false,
  keywordstyle=\fontfamily{pcr}\color[rgb]{0,0,0}\bfseries,
  %commentstyle=\color[rgb]{0.133,0.545,0.133},
  %stringstyle=\color[rgb]{0.627,0.126,0.941},
  breaklines=false,
  frame=none
  breaklines=false,
  frame=none,
  numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt,
  %frameround=fttt,
  %frame=single,
  escapeinside={(*@}{@*)},
  %columns=fullflexible
}


\lstnewenvironment{codenv}{\lstset{language=Scala}}{}
\lstnewenvironment{codenvOpt}[1]{\lstset{language=Scala,#1}}{}


\newenvironment{bluetext}{\color{blue}}{\ignorespacesafterend}
\newenvironment{redtext}{\color{red}}{\ignorespacesafterend}
\newcommand{\bygerold}[1]{ \begin{bluetext} #1 \end{bluetext}}
\newcommand{\commentbygerold}[1]{\\\begin{redtext} #1 \end{redtext}\\}

%\newenvironment{codenv}{\small \begin{itshape}}{ \end{itshape}}



%\renewcommand*{\bibfont}{\footnotesize}



% Avoid (not that) big pictures alone in a blank page
\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}

\usepackage{xspace}
\newcommand{\REScala}{{\small \sc{REScala}}\xspace}


\newcommand{\mm}[1]{\todo[color=green!40]{#1}}
\newcommand{\jd}[1]{\todo[color=blue!40]{#1}}
\newcommand{\gs}[1]{\todo[color=red!40]{#1}}

\usepackage{color}


\hyphenation{Res-ca-la}


\newcommand{\str}[1]{{\sf\selectfont @#1@}\newline}





\title{REScala Reference Manual}

\date{November 2013}

\author{Guido Salvaneschi\\ Technical University of Darmstadt\\
\code{salvaneschi@informatik.tu-darmstadt.de}\\}


\begin{document}

\maketitle
\newpage
\pagenumbering{Roman}
\tableofcontents
%\newpage
%\listoffigures
%\newpage
%\listoftables
\newpage
\pagenumbering{arabic}







\section{Signals and Vars}

A signal is language concept for expressing functional dependencies
among values in a declarative way. Intuitively, a reactive value can
depend on variables -- sources of change without further dependencies
-- or on other reactive values.  When any of the dependency sources
changes, the expression defining the reactive value is automatically
recomputed by the language runtime to keep the reactive value
up-to-date.

Consider the following example:

\begin{codenv}
var a = 2
var b = 3
var c = a + b   (*@\label{sum}@*)
println(a,b,c) // -> (2,3,5)
a = 4
println(a,b,c) // -> (2,4,5) (*@\label{nomore}@*)
c = a + b (*@\label{update}@*)
println(a,b,c) // -> (4,3,7)
\end{codenv}

Line~\ref{sum} specifies the value of \code{c} as a function of
\code{a} and \code{b}. Since Line~\ref{sum} defines a statement, the
relation $c = a + b$ is valid after the execution of
Line~\ref{sum}. Clearly, when the value of \code{a} is updated, the
relation $c = a + b$ is not valid anymore (Line~\ref{nomore}). To make
sure that the relation still holds, the programmer needs to recompute
the expression and reassign \code{c}, like in line \ref{update}.
\\

Reactive programming and REScala provide abstraction to express {\em
  constraints} in addition to statements. In REScala the programmer
can specify that the constraint $c := a + b$ {\em always} holds during
the execution of a program, and every time \code{a} o \code{b} change,
the value of \code{c} is automatically recomputed.

For example:
\begin{codenv}
val a = Var(2)
val b = Var(3)
val c = Signal{ a() + b() }   (*@\label{sumS}@*)
println(a.getVal,b.getVal,c.getVal) // -> (2,3,5)
a()= 4
println(a,b,c) // -> (2,4,5) (*@\label{updated}@*)
println(a.getVal,b.getVal,c.getVal) // -> (4,3,7)
\end{codenv}

In the code above, the \code{Signal} in Line~\ref{sumS} defines the
constraint $c := a + b$. When one of the variables involved in the
constraint is updated (Line~\ref{updated}), the expression in the
constraint is recomputed behind the scenes, and the value of \code{a}
is automatically updated.

As the reader may have noticed, expressing constraints in REScala
requires to conform some syntactic conventions. 


\paragraph{Defining Vars} Programmers express reactive computations
starting from vars. Vars wrap normal Scala values. For example
\code{Var(2)} create a var with an \code[Int] value and initializes it
to the value 2.

\paragraph{Assigning Vars} Vars can be directly modified with the
\code{()=} operator. For example \code{v()=3} replaces the current
value of the \code{v} var with \code{3}.

\paragraph{Defining Signals} Signals are defined by the syntax
\code{Signal\{}{\it sigexpr}\code{\}}.

\paragraph{Signal expressions} When, inside a signal expression
defining a signal \code{s}, a var or a signal is called with the
\code{()} operator, the var of the signal are added to the values
\code{s} depends on. In that case \code{s} {\it is a dependency} of
the vars and the signals in the signal expression.

\paragraph{Reading reactive values} The current value of





\section{Events}


\section{Imperative events}

\subsubsection{Defining  Events}

REScala supports imperative events. Imperative events are defined by
the \code{ImperativeEvent[T]} type. The value of the parameter
\code{T} defines the value that is attached to an event.

Fir example the following code snippet defines and imperative events
whose attached value is an integer:
\begin{codenv}
val e = new ImperativeEvent[Int]()
\end{codenv}

\subsubsection{Registering Handlers}

Handlers can be defined attaching a code block to the event. The
\code{+=} operator attaches the handler to the event.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }
\end{codenv}

- Other ways to register a handler ? Alternative syntax for handlers


When a handler is registered to an event, the handler is executed
every time the event is fired. If multiple handlers are registered,
all of them are executed when the event is fired. Applications should
not rely on any specific execution order for handler execution.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }
\end{codenv}


The signature of the event handlers must conform the signature of the
events.





\subsubsection{Firing Events}


Events can be fired with the same syntax of a method call. For example
the event \code{e} in the following example is fired by the
\code{e(10)} call.

\begin{codenv}
val e = new ImperativeEvent[Int]()
e(10)
\end{codenv}



\subsubsection{Registering Handlers}

Handlers can be unregistered from events by the \code{-=} operator.

\begin{codenv}
val e = new ImperativeEvent[Int]()

e += { println() }


e += { println() }
\end{codenv}




\section{Declarative Events}


REScala supports declarative events, which are defined as a
combination of other events. For this purpose it offers operators like
$e_1||e_2$ (occurrence of one among $e_1$ or $e_2$), $e_1\&\&p$ ($e_1$
occurs and the predicate $p$ is satisfied), $e_1.map(f)$ (the event
obtained by applying $f$ to $e_1$).  Event composition allows to
express the application logic in a clear and declarative way. Also,
the update logic is better localized because a single expression
models all the sources and the transformations that define an event
occurrence.

\section{Conversion Functions}

The \REScala interface between signals and events exposed by the
\code{Signal} trait.
\vspace{2mm}

\begin{scriptsize}
\noindent
  {\sf -- Creates a signal by folding events with a given function.}\\
  \hspace*{2mm}\codefs{fold[T,A](e: Event[T], init: A)(f :(A,T)=>A): Signal[A]}

\noindent
  {\sf-- Returns a value computed by \code{f} on the occurrence of an event.}\\
  \hspace*{2mm}\codefs{iterate[A](e: Event[\_], init: A)(f: A=>A)
    :Signal[A]}

  \noindent
  {\sf-- Returns a signal holding the latest value of the event \code{e}.}\\
  \hspace*{2mm}\codefs{hold[T](e: Event[T], init: T): Signal[T]}

  \noindent
  {\sf-- Holds the latest value of an event as \code{Some(val)} or \code{None}.}\\
  \hspace*{2mm}\codefs{holdOption[T](e: Event[T]): Signal[Option[T]]}

\noindent
  {\sf-- Returns a signal which holds the last \code{n} events.}\\
  \hspace*{2mm}\codefs{last[T](e: Event[T], n: Int): Signal[List[T]]}

\noindent
  {\sf-- Collects the event values in a reactive list.}\\
  \hspace*{2mm}\codefs{list[T](e: Event[T]): Signal[List[T]]}

\noindent
  {\sf-- On the event, sets the signal to one generated by the factory.}\\
  \hspace*{2mm}\codefs{reset[T,A](e: Event[T], init: T)(f: (T)=>Signal[A]): Signal[A]}

\noindent
  {\sf-- Switches the value of the signal on the occurrence of \code{e}.}\\
  \hspace*{2mm}\codefs{switchTo[U](e :Event[U])(f: U=>T): Signal[T]}\\
  \hspace*{2mm}\codefs{switchTo(e: Event[T]): Signal[T]}

  \noindent
  {\sf-- Switches to a new signal once, on the occurrence of \code{e}.}\\
  \hspace*{2mm}\codefs{switchOnce(e: Event[\_])(op: =>T): Signal[T]}\\
  \hspace*{2mm}\codefs{switchOnce(e: Event[\_], newSignal: Signal[T]): Signal[T]}

  \noindent
  {\sf-- Switches between signals on the event \code{e}.}\\
  \hspace*{2mm}\codefs{toggle(e: =>Event[\_])(op: =>T): Signal[T]}\\
  \hspace*{2mm}\codefs{toggle(e: =>Event[\_], other: Signal[T]): Signal[T]}

\noindent
  {\sf-- Returns a signal updated only when \code{e} fires.}\\
  \hspace*{2mm}\codefs{snapshot(e: Event[\_]): Signal[T]}

\noindent
\hspace{-1.8mm}
\fbox{\parbox[100]{0.98\linewidth}{
  {\sf -- Open interface between signals and events.}\\
  \hspace*{2mm}\codefs{switch(e: Event[T])(fact: Factory[T,A]): Signal[A]}\\
  \hspace*{2mm}\codefs{Factory[T,A].apply(eVal: T): (Signal[A], Factory[T,A])}
}}

%  \hspace*{2mm}\codefs{switch(init :Signal[A])(fact :Factory[T,A]) :Signal[A]}\\
%  \hspace*{2mm}\codefs{Factory[T,A].apply(eVal :T) :(Signal[A], Factory[T,A])}
\end{scriptsize}





\section{Technicalities}~\label{sec:technicalities}

To work with REScala you need to properly import the reactive
abstractions offered by the language. The following imports are
normally sufficient for all REScala functionalities:

\begin{codenv}
import react._
import react.events._
import macro.SignalMacro.{SignalM => Signal}
\end{codenv}

Note that signal expressions are currently implemented as macros,
i.e. the body of a signal expression is macroexpanded. To use macros
for signal expressions, the macro \code{SignalM} is imported and
renamed to \code{Signal} (Line 3).




\section{Common Pitfalls}~\label{sec:pitfalls} In this section we
collect some mistakes that are common to users that are new to
reactive programming and REScala. 


\paragraph{Accessing values in signal expressions} The \code{()}
operator used on a signal or a var, inside a signal expression,
returns the signal/var value {\it and} creates a dependency. The
\code{getVal} operator returns the current value but does {\it not}
create a dependency. For example the following signal declaration
creates a dependency between \code{a} and \code{s}, and a dependency
between \code{b} and \code{s}.
\begin{codenv}
val s = Signal{ a() + b() }
\end{codenv}
The following code instead establishes only a dependency between
\code{b} and \code{s}.
\begin{codenv}
val s = Signal{ a.getVal + b() }
\end{codenv}
In other words, if \code{a} is updated, \code{s} is not automatically
updated. With the exception of rare cases in which this behavior is
desirable, this is almost certainly a mistake. As a rule of dumb,
signals and vars appear in signal expressions with the \code{()}
operator.


\paragraph{Attempting to assign a signal} Signals are not
assignable. Signal depends on other signals and vars, the dependency
is expressed by the signal expression. The value of the signal is
automatically updated when one of the values it depends on
changes. Any attempt to set the value of a signal manually is a
mistake.


\paragraph{Side effects in signal expressions} Signal expressions
should be pure. i.e. they should not modify external variables. For
example the following code is conceptually wrong because the variable
\code{c} is imperatively assigned form inside the signal expression
(Line~\ref{assign}).
\begin{codenv}
var c = 0                 /* WRONG - DON'T DO IT */
val s = Signal{ 
  val sum = a() + b(); 
  c = sum * 2  (*@\label{assign}@*)
}
 ...
foo(c)
\end{codenv}

A possible solution is to refactor the code above to a more functional
style. For example by removing the variable \code{c} and replacing it
directly with the signal.
\begin{codenv}
val c = Signal{ 
  val sum = a() + b(); 
  sum * 2  
}
 ...
foo(c.getVal)
\end{codenv}






\paragraph{Objects and mutability} Consider a signal \code{s} with a
signal expression {\it sigexpr}. When one of the reactives the signal
depends on is updated, the entire signal expression is evaluated
again.

TODO





\section{Related Work}~\label{sec:related}

A complete bibliography on reactive programming is beyond the scope of
this work. The interested reader can refer
to~\cite{rective-progr-survey} for an overview of reactive programming
and to~\cite{Salvaneschi:2013:RBO:2451436.2451442} for the issues
concerning the integration of RP with object-oriented programming.


REScala builds on ideas originally developed in
EScala~\cite{Gasiunas:2011:EME:1960275.1960303} -- which supports
event combination and implicit events. Other reactive languages
directly represent time-changing values and remove inversion of
control. Among the others, we mention
FrTime~\cite{DBLP:conf/esop/CooperK06} (Scheme),
FlapJax~\cite{Meyerovich:2009:FPL:1640089.1640091} (Javascript),
AmbientTalk/R~\cite{ambienttalkR} and
Scala.React~\cite{EPFL-REPORT-148043} (Scala).


\section{Acknowledgments}

Several people contributed to this manual with their comments. Among
the others Gerold Hintz and Pascal Weisenburger.


\bibliographystyle{abbrv}
\bibliography{manual}




\end{document}














